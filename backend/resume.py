# resume parsing imports
from pypdf import PdfReader
from docx import Document
import os
from io import BytesIO
import re

#openai related imports
from dotenv import load_dotenv
from openai import AsyncOpenAI

# Load the .env file
load_dotenv()

# Get the API key from the .env file
try:
    openai_api_key = os.getenv("OPENAI_API_KEY")
    if not openai_api_key:
        raise ValueError("OPENAI_API_KEY not found or is not set.")
except Exception as e:
    print(f"Error: {e}")
    raise

# Initialize the OpenAI API client
client = AsyncOpenAI()

# Check if the API key is valid
def check_api_key():
    if client.api_key:
        print("OpenAI API key found.")
    else:
        print("OpenAI API key not found. Please set the OPENAI_API_KEY environment variable.")

"""
    The function `getResumeFeedback` uses an AI prompt to analyze a resume and job description,
    providing structured feedback on skills alignment, experience relevance, key achievements, missing
    keywords, overall structure and formatting, and a summary for improvement suggestions.
    
    :param job_description: The `getResumeFeedback` function you provided seems to be a structured way
    to analyze a resume in comparison to a job description and provide feedback on skills alignment,
    experience relevance, key achievements, missing keywords, overall structure and formatting, and a
    summary assessment
    :param resume_text: The `getResumeFeedback` function you provided seems to be a structured way to
    analyze a resume in comparison to a job description and provide feedback on skills alignment,
    experience relevance, key achievements, missing keywords, overall structure and formatting, and a
    summary assessment
    :return: The `getResumeFeedback` function returns the response generated by the AI model based on
    the provided job description and resume text. The response includes a detailed comparison and
    suggestions to improve the resume to better match the job requirements. The response is structured
    into sections such as Skills Alignment, Experience Relevance, Key Achievements, Missing Keywords,
    Overall Structure and Formatting, and Summary, each providing specific insights and recommendations
"""
async def getResumeFeedback(job_description, resume_text):
    
    # ai prompt used to extract and categorize skills from a job description
    ai_prompt = f"""Analyze the following resume and job description. Provide a detailed comparison and suggestions to improve the resume to better match the job requirements. Do not assume anything or hypothesize unless the user has specified it. If something is unclear, use that as a suggestion for the user to specify. Structure your response in the following format:

    Skills Alignment:
        Skills mentioned in the job description:
            • example
            • example

        Matching skills found in the resume:
            • example
            • example(repeat this for the rest of the lines)

        Suggested skills to add or emphasize:

    Experience Relevance:
        Relevant experience from the resume:

        Missing experience based on job requirements:

        Suggested ways to bridge any experience gaps:

    Key Achievements:
        Notable achievements from the resume:

        Suggested additional achievements that could be highlighted:

    Missing Keywords:
        Identified important keywords from the job description not found in the resume:

        Suggested ways to incorporate these keywords:

    Overall Structure and Formatting:
        Comments on the resume's current structure:

        Suggested improvements in formatting or organization:

    Summary:
        A brief overall assessment:

        List top 3 areas for improvement:

    Resume:
    {resume_text}

    Job Description:
    {job_description}

    Provide your analysis and suggestions in the structured format described above(keep in mind of the spacing and tabs). 
    Please avoid using any special formatting, like "**" and "###".
    Format headers like "Skills mentioned in the job description:" and "Matching skills found in the resume:" as bold.
    """
    completion = await client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[
            {"role": "system", "content": "You are a hiring manager looking to hire a software engineer."},
            {"role": "user", "content": f"{ai_prompt}"},
        ]
    )

    ai_response = completion.choices[0].message.content
    return ai_response

"""
    This function parses different sections of feedback based on specific patterns and stores them in a
    dictionary.
"""
def parseFeedback(feedback):
    sections = {
        "skills": "",
        "experience": "",
        "achievements": "",
        "keywords": "",
        "structure": "",
        "summary": ""
    }

    patterns = {
        "skills": r"\s*Skills Alignment:\s*(.*?)(?=\s*Experience Relevance:|$)",
        "experience": r"\s*Experience Relevance:\s*(.*?)(?=\s*Key Achievements:|$)",
        "achievements": r"\s*Key Achievements:\s*(.*?)(?=\s*Missing Keywords:|$)",
        "keywords": r"\s*Missing Keywords:\s*(.*?)(?=\s*Overall Structure and Formatting:|$)",
        "structure": r"\s*Overall Structure and Formatting:\s*(.*?)(?=\s*Summary:|$)",
        "summary": r"\s*Summary:\s*(.*)"
    }

    for key, pattern in patterns.items():
        print(f"Matching pattern for section '{key}': {pattern}")  # Debugging statement
        match = re.search(pattern, feedback, re.DOTALL)
        if match:
            section_text = match.group(1).strip()
            # Remove unwanted standalone characters and formatting
            section_text = re.sub(r" - ", " • ", section_text)  # Replace standalone " - " with " • "
            section_text = re.sub(r"- ", "", section_text)  # Remove leading "- " from lines
            section_text = re.sub(r"\*\*", "", section_text)   # Remove "**"
            section_text = re.sub(r"###", "", section_text)    # Remove "###"
            # Remove leading spaces from lines that don't start with a bullet point
            section_text = re.sub(r"(?m)^(?!\s*•)\s+", "", section_text)

            sections[key] = section_text
        else:
            pass

    return sections


# TODO: save resume into a database using resume.save('uploads/')... etc
"""
    The function `resumeTextExtraction` extracts text content from PDF and DOCX files provided as input
    resumes.
    
    :param resume: The `resumeTextExtraction` function is designed to extract text content from a resume
    file sent through a POST request. It first checks the file extension of the resume file to determine the format (PDF or DOCX).
    If the file is a PDF, it uses PyPDF2 to extract text from each page. If the
    :return: The `resumeTextExtraction` function returns the extracted text content from the provided
    resume file. If the file extension is '.pdf', it extracts text from each page of the PDF using
    PyPDF2 library. If the file extension is '.docx', it extracts text from paragraphs in the Word
    document using python-docx library. If the file format is not supported, it raises a ValueError.
"""
def resumeTextExtraction(resume):
    file_extension = os.path.splitext(resume.filename)[1].lower()

    if file_extension == '.pdf':
        reader = PdfReader(resume.stream)
        resume_pages = [page for page in reader.pages]
        resume_text = ""
        for page in resume_pages:
            resume_text += page.extract_text()
        
        return resume_text
    elif file_extension == '.docx':
        doc_bytes = BytesIO(resume.read())
        doc = Document(doc_bytes) 
        resume_text = ""
        for paragraph in doc.paragraphs:
            resume_text += paragraph.text + "\n"
        return resume_text
    elif file_extension == '.txt':
        resume_text = resume.stream.read().decode('utf-8')
        return resume_text
    else:
        raise ValueError('Unsupported file format')
    